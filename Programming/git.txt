git init
git clone url						// it creates the repository on the device or we can say it copies the repo to device
git add . (or filename)

A commit in Git saves a snapshot of your tracked files. Git optimizes storage by saving deltas (changes) instead of full copies.
git commit -m "Message"

git push urlname branch				
git push -u origin main // push my local main to the remote origin/main, and -u option set origin/main as the upstream branch for local main
git push origin master -f				// force push
git pull
git remote -v						// lets you view remote repo URLs
git remote add origin(urlname) url (it attach the url with the project on your device)
git status
git log
git checkout -- filename				// discard changes in working directory
git checkout file.txt					// it rolls back this file to the previous version
git restore --staged filename or git rm --cached -r .	// it unstage files
git stash						// temporarily save uncommitted changes
git stash pop						// restore stashed changes
git stash clear
git diff file.txt					// it check the difference of current version and last saved point

--> Git Remote
A Git remote is just a copy of your repository on another machine, often on the internet (like GitHub). It allows your local Git repo to communicate with others, typically for collaboration or backup.

When we do git clone, we see a new branch in our local repository called origin/main. This type of branch is called a remote branch. Remote branches reflect the state of remote repositories (since you last talked to those remote repositories). These branches help compare your local work with the public version of the project.

origin/main → origin is the remote name (default after cloning), main is the branch.
To be clear: Remote branches are on your local repository, not on the remote repository (GitHub).

Checking out a remote branch (like git checkout origin/main) puts you in detached HEAD mode — you can't commit directly on it as they are readonly. We have to work elsewhere on a branch, and then share the work with remote repo.

--> Remote-Tracking Branches
When you clone a repo, Git automatically connects your local main to the remote repo origin/main. This connection is called remote tracking.

What Does Remote Tracking Do?
During git pull: Git knows to fetch and merge from origin/main into your local main.
During git push: Git pushes from your local main to origin/main.
This is possible because main is tracking origin/main.

How Is This Set?
Automatically when you clone a repo:
Git creates local branch main that tracks origin/main.
Other remote branches are visible but not checked out locally.

Manually Set a Tracking Branch:
Way 1: When creating a branch
git checkout -b newBranch origin/main			// Creates newBranch that tracks origin/main.

Way 2: Set tracking on an existing branch
git branch -u origin/main foo

Or if foo is checked out:
git branch -u origin/main

Summary:
Tracking links a local branch to a remote one.
This defines where to pull from and where to push to.
You can change or set it manually as needed.

--> Reset and Revert
While git reset works great for local branches on your own machine, its method of "rewriting history" doesn't work for remote branches that others are using. In order to reverse changes and share those reversed changes with others, we need to use git revert.

Eg. git reset HEAD~1 or git reset --hard log_id
Eg. gir revert HEAD

A new commit plopped down below the commit we wanted to reverse using revert command. That's because the new commit C2' introduces changes -- it just happens to introduce changes that exactly reverses the commit of C2. With reverting, you can push out your changes to share with others.

--> Branching
Branches are simply pointers to a specific commit -- nothing more.There is no storage / memory overhead with making many branches, it's easier to logically divide up your work than have big beefy branches. When we start mixing branches and commits, we will see how these two features combine. A branch essentially says "I want to include the work of this commit and all parent commits."
Merging combines changes from one branch into another. It creates a special commit with two parents, preserving both histories. Common use case: merge a feature branch back into main.

git branch branchName 					// creates a branch
git checkout branchName 				// to change branch
git switch branchName					// new command and alternative of checkout
git checkout -b [yourbranchname]			// creates a new branch AND check it out at the same time
git merge branchName
git mergetool						// resolve merge conflicts
git cherry-pick <commit>				// apply a specific commit to current branch

--> Rebase
The second way of combining work between branches is rebasing (first was merging). Rebasing essentially takes a set of commits, "copies" them, and plops them down somewhere else.
Rebase moves your commits on top of another branch. It replays your changes to create a clean, linear history. Useful for tidying up before merging.

git checkout feature-x					// switch to your branch
git rebase main						// reapply feature-x commits onto main

The above commands explanation, let's say I am working on a feature on a different branch and after testing that feature I want to merge that branch to the main branch below it. So to do that we have to checkout on feature branch and then do git rebase main which will add the feature branch below the last commit that was done by main branch. Another eg. -
Let's say we have this C0<---C1(main)<---C2(newImage)<---C3(caption*) and we want to change the order of the newImage and caption. We can do using git rebase -i HEAD~2 which create new branch with the result that we wanted.

git rebase caption main means: "Take the changes in the caption branch and reapply them on top of the main branch". Simply it mean, apply the changes in main branch below caption branch.

Pick and squash- It is to simply merge many commits into single commits.
git rebase -i commit_id/HEAD~2					// i means interactive environment

--> HEAD
HEAD always points to the most recent commit which is reflected in the working tree. Normally HEAD points to a branch name (like main). When you commit, the status of main is altered and this change is visible through HEAD.
Detaching HEAD just means attaching it to a commit instead of a branch. This is what it looks like beforehand:
HEAD -> main -> C1 (they both point to commit C1)
After git checkout C1:
HEAD -> C1

--> Relative Refs
Specifying commits by their hash isn't the most convenient thing ever, which is why Git has Relative Refs. With relative refs, you can start somewhere memorable (like the branch bugFix or HEAD) and work from there.

Relative commits are powerful, but we will introduce two simple ones here:
Moving upwards one commit at a time with ^
Moving upwards a number of times with ~num
Eg. git checkout main^					// C0<---C1<---C2(main), this command put HEAD on C1
So saying main^ is equivalent to "the first parent of main" and main^^ is the "grandparent of main".
Eg. git checkout HEAD~4

--> Branch forcing
You can directly reassign a branch to a commit with the -f option. So something like:
git branch -f main HEAD~3				// moves (by force) the main branch to three parents behind HEAD.

Note: In a real git environment git branch -f command is not allowed for your current branch. So you can use these:
Option 1: Use git reset
If you want to move the current branch (like main) to a new commit, use:
git reset --hard HEAD~3

Option 2: Check out a different branch, then force-move the original
git checkout other-branch
git branch -f main HEAD~3

--> Cherry-pick
It's a way for developers to say "I want this work here and that work there" in precise, eloquent, flexible ways.
git cherry-pick <Commit1> <Commit2> <...> or git cherry-pick C2 C4;
It's a very straightforward way of saying that you would like to copy a series of commits below your current location (HEAD).

--> Git Tag
A tag in Git is like a label you stick on a specific commit to mark it as important — usually for releases, milestones, or versioning (e.g. v1.0.0).
Eg. git tag v1.0.0 C1					// if C1/commit not specified then tag is set on current checkout branch.

Tags are stable, read-only markers for commits. You can’t commit on them, but you can check them out, archive, or share them. A tag doesn't replace or block the branch — it just marks a specific commit on that branch as important. Think of a tag as a “sticky note” on a specific page of a book. You can still keep writing more pages (committing on the branch),but the sticky note (tag) tells you:
“This was version 1.0 — don’t forget it.”

We can still commit on the main branch after tagging but can't if we chekout on tag v1.0:
✅ Committing on a branch that has a tag pointing to it
git checkout main
git commit -m "New work"

❌ Committing while checked out directly on a tag (detached HEAD)
git checkout v1.0
git commit -m "Trying to change this"

--> Git describe
It tells you where you are in the commit history relative to the nearest tag. Super helpful when debugging or working on unfamiliar commits.
Eg. git describe or git describe <ref>(xyz commit, tag or branch)	// uses current commit if no <ref> is provided
Output format: <tag>_<numCommits>_g<hash>				// v1.0_3_g4f9a12d
Where tag is the closest ancestor tag in history, numCommits is how many commits away that tag is, and <hash> is the hash of the commit being described.

--> Specifying Parents
Like the ~ modifier, the ^ modifier also accepts an optional number after it.

Rather than specifying the number of generations to go back (what ~ takes), the modifier on ^ specifies which parent reference to follow from a merge commit. Remember that merge commits have multiple parents, so the path to choose is ambiguous.

Git will normally follow the "first" parent (directly above the merge commit) upwards from a merge commit, but specifying a number with ^ changes this default behavior.
git checkout main^					// first parent of `main` (usually the branch you merged *into*)
git checkout main^2					// second parent (the branch that was *merged in*)

git checkout HEAD~; git checkout HEAD^2; git checkout HEAD~2
These modifiers can be changed together like this for the above command:
git checkout HEAD~^2~2;

--> Fetch
git fetch is used to update remote tracking branches (like origin/main) to match the current state of the remote repository — but it doesn't change your working directory or local branches.
git fetch						// Updates all remote branches
git fetch origin					// Updates branches from the 'origin' remote i.e. origin/...
git fetch upstream					// Only fetch from upstream i.e. upstream/...

--> Pull
Since fetching + merging is a common workflow, Git provides a shortcut:
git pull

--> Push
Once you've fetched and integrated remote changes locally, you’ll likely want to share your own updates with others. That’s where git push comes in. Running git push without arguments behaves differently based on the push.default setting. In most modern setups, it's set to upstream, which pushes to the branch your current branch is tracking. You can check it using:
git config --get push.default

What git push Does:
Sends your commits to a remote branch.
Updates the remote repo so others can fetch or pull your changes.
Essentially, it's how you publish your work.

Example:
git push origin main					// pushes your current branch to the main branch on the origin remote.

--> Diverged Work
Sometimes your local branch falls behind the remote because others have pushed new commits. If you try to git push, Git will reject it due to a divergence in commit history.

Why This Happens:
Your work is based on an outdated version.
Git doesn't know how to safely combine your changes with the newer remote history.
So it forces you to update your branch first.

How to Fix It:
Option 1: Rebase (Clean History)
git fetch; git rebase origin/main; git push;
Re-applies your changes on top of the latest remote commits.

Option 2: Merge (Preserves History)
git fetch; git merge origin/main; git push;
Merges the latest changes from remote into your branch, creating a merge commit.

Shortcut:
git pull --rebase; git push;
Equivalent to fetch + rebase + push, all in fewer steps.

--> Merging Feature Branches
When working on a project, developers usually:
1. Create and work on a feature branch.
git checkout -b feature-xyz

2. Push the feature branch to remote for collaboration or backup.
git push origin feature-xyz

3. Once done, switch to main, pull latest changes, and merge the feature.
git checkout main
git pull origin main     # Update local main with latest changes
git merge feature-xyz    # Merge feature into main
git push origin main     # Push updated main to remote

--> Merge vs Rebase – Why Prefer Rebase?
To update your branch with remote changes, you can either:
git merge origin/main
git rebase origin/main
Both work, but many developers prefer rebase. Here's why:

Rebase Pros:
Creates a clean, linear history — no messy merge commits.
Easier to read with tools like git log or GitHub PRs.

Rebase Cons:
Rewrites history: Commits appear in a different order than they were created.
Can be confusing if misused in shared branches.

Merge Pros:
Preserves true history (no changes to commit order).
Safer for public/shared branches.

Bottom Line:
Rebase = Clean, simple history.
Merge = Accurate, detailed history.
Use whichever fits your team’s style — it's mostly preference!

-->
upstream is the name of the url from where you forked the project.
To maintain the upstream main branch with the fork main branch if something was merged in the upstream -
git fecth --all --prune			// it fecthes all the branches and prune is to fetch the deleted changes or commits too to your fork
git checkout main 
git reset --hard upstream/main				// resets the main branch of origin to the main branch of upstream
             or
git pull upstream main

git config --global credential.helper 'cache --timeout=90000000000000000000000'
				or
git config --global credential.helper cache
git config --global --unset credential.helper